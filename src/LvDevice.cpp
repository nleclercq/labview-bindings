// ============================================================================
//
// = CONTEXT
//   This is part of the Tango binding for LabVIEW
//
// = FILENAME
//   LvDevice.cpp
//
// = AUTHOR
//   Nicolas Leclercq - Synchrotron SOLEIL - France
//
// ============================================================================

#include "Config.h"

#if defined (_TBFL_HAS_DEVICE_SERVER_SUPPORT_)

//=============================================================================
// DEPENDENCIES
//=============================================================================
#include <yat4tango/InnerAppender.h>
#include "CommonHeader.h"
#include "Types.h"
#include "LvDeviceProxy.h"
#include "DataAdapter.h"
#include "ErrorStack.h"
#include "LvDeviceImpl.h"
#include "LvDeviceServer.h"
#include "LvDeviceRepository.h"

//=============================================================================
// LvDevice::LvDevice
//=============================================================================
LvDevice::LvDevice ()
 : enabled_(false),
   interface_changed_(false),
   self_init_requested_(false),
   state_machine_(),
   ds_executable_name_("unspecified_executable_name"),
   ds_instance_name_("unspecified_instance_name"),
   class_name_("unspecified_classe_name"),
   original_class_name_("unspecified_classe_name"),
   device_name_("unspecified/device/name"),
   device_class_(0),
   class_interface_(0),
   device_impl_(0),
   lv_evt_ref_(0),
   lv_evt_source_id_(0),
   client_request_cnt_(0),
   tg_device_intf_(0),
   cl_rq_ack_tmo_in_ms_(0),
   cl_rq_mtx_(),
   cl_rq_cdt_(cl_rq_mtx_),
   exc_data_buffers_(),
   rda_data_buffers_(),
   dim_(0)
{
  TBFL_TRACE(this);

  //- set client request timeout
  set_client_request_timeout(DEFAULT_CLIENT_REQ_TMO_IN_SEC);
}

//=============================================================================
// LvDevice::~LvDevice
//=============================================================================
LvDevice::~LvDevice ()
{
  delete tg_device_intf_;
  tg_device_intf_ = 0;

  LvClientRequestReplyDataBufferMapIterator it = exc_data_buffers_.begin(); 
  for ( ; it != exc_data_buffers_.end(); ++it )
    _BEST_EFFORT_TRY_(it->second.release());
  exc_data_buffers_.clear();

  it = rda_data_buffers_.begin();
  for ( ; it != rda_data_buffers_.end(); ++it )
    _BEST_EFFORT_TRY_(it->second.release());
  rda_data_buffers_.clear();

  //- do not delete the dynamic interface manager (i.e. the dim_ member) 
  //- it will otherwise try to remove the dyn. interface from a device which 
  //- could not be the initial one (e.g. in case a 'restart device' has been executed from Jive)
  //- not a big deal since 'this' lifetime equals app lifetime (no leak in fact)
}

//=============================================================================
// LvDevice::init_device
//=============================================================================
void LvDevice::init_device (LvDeviceImpl* dev_impl, tbfl::int32 init_cnt)
{
  TBFL_TRACE(device_name_);

  //- store pointer to the Tango device impl. locally
  device_impl_ = dev_impl;

  //- get device properties
  get_device_properties();

  //- (re)build the dynamic interface
  reload_dynamic_interface();    

  //- we are now enabled!
  enabled_ = true;

  //- invoke the labview implementation of init
  ClientRequest pcr(CLIENT_REQ_EXEC_CMD, "Init");
  if ( ! init_cnt || self_init_requested_ )
  {
    //- first call is async. (generated locally by the Tango kernel as a consequence of a LabVIEW call)
    self_init_requested_ = false;
    post_client_request(pcr);
  }
  else
  {
    //- next calls are sync. (generated by external client calls)
    wait_client_request_handled(pcr);
  }
}

//=============================================================================
// LvDevice::init_device
//=============================================================================
void LvDevice::init_device ()
{
  TBFL_TRACE(device_name_);

  //- nice trick here: exec "init" from the Tango side using a proxy to ourselves! 
  //- nice trick here: this prevent us from having to deal with the device monitor

  omni_thread::ensure_self es;

  Tango::DeviceProxy dp(device_name_);

  self_init_requested_ = true;
  dp.command_inout_asynch("Init", true);
}

//=============================================================================
// LvDevice::delete_device
//=============================================================================
void LvDevice::delete_device ()
{
  TBFL_TRACE(device_name_);

  client_request_cnt_ = 0;

  delete tg_device_intf_;
  tg_device_intf_ = 0;

  LvClientRequestReplyDataBufferMapIterator it = rda_data_buffers_.begin();
  for ( ; it != rda_data_buffers_.end(); ++it )
    _BEST_EFFORT_TRY_(it->second.release());

  _BEST_EFFORT_TRY_(clear_client_request_queues());
}

//=============================================================================
// LvDevice::get_tango_db_address
//=============================================================================
void LvDevice::get_tango_db_address (std::string& host, int& port)
  throw (Tango::DevFailed)
{
  std::string tango_host;
  int err = Tango::ApiUtil::get_env_var("TANGO_HOST", tango_host);
  if ( err )
  {
    Tango::Except::throw_exception(_CPTC_("internal error"),
                                   _CPTC_("no Tango database available [is the TANGO_HOST env. var. properly defined?]"),
                                   _CPTC_("LvDevice::get_tango_db_address"));
  }

  tbfl::size_t p1 = tango_host.find(":");
  if ( p1 == std::string::npos )
  {
    Tango::Except::throw_exception(_CPTC_("internal error"),
                                   _CPTC_("TANGO_HOST env. var. is not properly set [syntax error]"),
                                   _CPTC_("LvDevice::get_tango_db_address"));
  }

  tbfl::size_t p2 = tango_host.find(",");
  p2 = ( p2 == std::string::npos ) ? tango_host.size() : --p2;

  host = tango_host.substr(0, p1);
  port = ::atoi(tango_host.substr(p1 + 1, p2 - p1).c_str()); 
}

//=============================================================================
// LvDevice::get_device_properties
//=============================================================================
void LvDevice::get_device_properties ()
  throw (Tango::DevFailed)
{
  if ( ! class_interface_ )
    return;
  
  try
  {
    //- get our property list from our class interface
    const std::vector<xmi::Property>& dpl = class_interface_->device_properties;
    if ( dpl.empty() )
      return;

#if defined(_TBFL_VERBOSE_)
    ostringstream oss;
    oss << "device " << device_name_ << " has the following properties: ";
    for ( tbfl::size_t i = 0; i < dpl.size(); i++ )
      oss << dpl[i].name << ( i < dpl.size() - 1 ? ", " : "" );
    TBFL_STDOUT(oss.str());
#endif
    
    //- get tango db address
    int db_port;
    std::string db_host;
    get_tango_db_address(db_host, db_port);

    //- instanciate a proxy to the tango db
    Tango::Database db(db_host, db_port);

    //- build list of properties to be read from database
    Tango::DbData dev_prop;
    for ( tbfl::size_t i = 0; i < dpl.size(); i++ )
      dev_prop.push_back(Tango::DbDatum(dpl[i].name));

    //- get properties from database
    Tango::DbDevice dbd(device_name_, &db);
    dbd.get_property(dev_prop);

    //- try to obtain the value of each property
    for ( tbfl::size_t i = 0; i < dpl.size(); i++ )
    {
      //- try to initialize the property from value defined at device level
      if ( ! dev_prop[i].is_empty() )
      {
        device_prop_[dpl[i].name] = dev_prop[i].value_string;
      }
      else if ( device_class_ )
      {
        //- try to initialize the property from value specified at class level
        Tango::DbData dbd;
        dbd.push_back(Tango::DbDatum(dpl[i].name));
        db.get_class_property(original_class_name_, dbd);
        Tango::DbDatum& class_prop = dbd[0];
        if ( ! class_prop.is_empty() )
        {
          device_prop_[dpl[i].name] = class_prop.value_string;
        }
        else if ( ! dpl[i].default_value.empty() )
        {
          std::vector<std::string> dpv;
          dpv.push_back(dpl[i].default_value);
          device_prop_[dpl[i].name] = dpv;
        }
      }
#if defined(_TBFL_VERBOSE_)
      std::ostringstream oss;
      oss << "prop[" << dpl[i].name << "] = ";
      std::vector<std::string>& p = device_prop_[dpl[i].name];
      for ( tbfl::size_t v = 0; v < p.size(); v++ )
        oss << p[v] << " ";
      TBFL_STDOUT(oss.str());
#endif  
    }
  }
  catch (Tango::DevFailed& df)
  {
    std::ostringstream oss;
    oss << "failed to obtain device properties from Tango database for device "
        << device_name_
        << " [Tango exception caught]";
    Tango::Except::re_throw_exception(df,
                                      _CPTC_("DEVICE_ERROR"),
                                      _CPTC_(oss.str().c_str()),
                                      _CPTC_("LvDevice::get_device_properties"));
  }
  catch (...)
  {
    std::ostringstream oss;
    oss << "failed to obtain device properties from Tango database for device "
        << device_name_
        << " [unknown exception caught]";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::get_device_properties"));
  }
}

//=============================================================================
// LvDevice::get_device_property
//=============================================================================
void LvDevice::get_device_property (const std::string&  pn, LvDevicePropertyPtr pv)
    throw (Tango::DevFailed)
{
  TBFL_TRACE(device_name_ + "/" + pn);

  if ( ! class_interface_ )
  {
    std::ostringstream oss;
    oss << "unexpected null pointer to class interface "
        << " [LvDevice "
        << device_name_
        << " is not properly initialized]";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::get_device_property"));
  }
  
  DevicePropertyMapIterator it = device_prop_.find(pn);
  if ( it == device_prop_.end() )
  {
    std::ostringstream oss;
    oss << "invalid property name specified for device "
        << device_name_
        << " [property '"
        << pn
        << "' does not exist]";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::get_device_property"));
  }

  PropertyInfo pi;
  pi.dev = device_name_;
  pi.name = pn;
  pi.data_type = class_interface_->device_property_data_type(pn);
  
  DATA_ADAPTER->tg_to_lv_device_property(pi, it->second, pv);
}
 
//=============================================================================
// LvDevice::get_attribute_info
//=============================================================================
void LvDevice::get_attribute_info (const std::string&  an, LvAttributeInfoPtr lai)
  throw (Tango::DevFailed)
{
  TBFL_TRACE(device_name_ + "/" + an);

  if ( ! lai )
  {
    std::ostringstream oss;
    oss << "invalid argument - unexpected null pointer to LvAttributeInfo "
      << " [LvDevice "
      << device_name_
      << " is not properly initialized]";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::get_attribute_info"));
  }

  if ( !class_interface_ || !device_impl_ )
  {
    std::ostringstream oss;
    oss << "unexpected null pointer "
      << " [LvDevice "
      << device_name_
      << " is not properly initialized]";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::get_attribute_info"));
  }

  try
  {
    Tango::Attribute& ta = device_impl_->get_device_attr()->get_attr_by_name(an.c_str());

    Tango::AttributeConfig tac;
    ta.get_properties(tac);

    DATA_ADAPTER->tg_to_lv_attribute_config(device_name_, tac, *lai);
  }
  catch ( ... )
  {
    throw;
  }
}

//=============================================================================
// LvDevice::set_attribute_info
//=============================================================================
void LvDevice::set_attribute_info (const std::string&  an, LvAttributeInfoPtr lai)
  throw (Tango::DevFailed)
{
  TBFL_TRACE(device_name_ + "/" + an);

  if ( ! lai )
  {
    std::ostringstream oss;
    oss << "invalid argument - unexpected null pointer to LvAttributeInfo "
        << " [LvDevice "
        << device_name_
        << " is not properly initialized]";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::set_attribute_info"));
  }

  if ( !class_interface_ || !device_impl_ )
  {
    std::ostringstream oss;
    oss << "unexpected null pointer "
        << " [LvDevice "
        << device_name_
        << " is not properly initialized]";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::set_attribute_info"));
  }

  try
  {
    Tango::Attribute& ta = device_impl_->get_device_attr()->get_attr_by_name(an.c_str());

    Tango::AttributeConfig tac;
    ta.get_properties(tac);

    DATA_ADAPTER->lv_to_tg_attribute_config(device_name_, *lai, tac);

    Tango::AttributeConfigList acl(1);
    acl.length(1);
    acl[0] = tac;

    //--------------------------------------------------------------------------------------------
    { //- begin of temporary serialization model block
      //------------------------------------------------------------------------------------------
      //- big trick here: 
      //- device monitor might be locked and it is not recursive. we consequently implement a trick in 
      //- order to avoid to relock the device monitor by temporarily changing the serialisation model - 
      //- we change it to Tango::BY_CLASS so that the underlying Tango implementation will not try to 
      //- relock the device monitor (i.e. mutex) - the initial serialization model is restored when the 
      //- TemporarySerializationModel object is destroyed - changing the serialization model to 
      //- Tango::BY_CLASS as no side effect cause this binding implements a virtual device class per 
      //- device (see LvDeviceServer for details)
      //------------------------------------------------------------------------------------------
      //- temporarily change the serialisation model
      TemporarySerializationModel sm(Tango::BY_CLASS);
      //- ok, let's change the attribute configuration
      device_impl_->set_attribute_config(acl);
      //------------------------------------------------------------------------------------------
    } //- end of temporary serialization model blocks
    //--------------------------------------------------------------------------------------------
  }
  catch ( ... )
  {

    throw;
  }
}

//=============================================================================
// LvDevice::enable
//=============================================================================
void LvDevice::enable ()
{
  TBFL_TRACE(device_name_);

  enabled_ = true;
}

//=============================================================================
// LvDevice::disable
//=============================================================================
void LvDevice::disable ()
{
  TBFL_TRACE(device_name_);

  enabled_ = false;
}

//=============================================================================
// LvDevice::start
//=============================================================================
void LvDevice::start ()
{
  TBFL_TRACE(device_name_);

  client_request_cnt_ = 0;
  init_device();
  enable();
}

//=============================================================================
// LvDevice::stop
//=============================================================================
void LvDevice::stop ()
{
  TBFL_TRACE(device_name_);

  disable();
  abort_client_requests();
}

//=============================================================================
// LvDevice::clear_client_request_queues
//=============================================================================
void LvDevice::clear_client_request_queues ()
{
  TBFL_TRACE(device_name_);
            
  clear_pending_client_request_map();
  empty_client_request_trash();
}

//=============================================================================
// LvDevice::clear_pending_client_request_map
//=============================================================================
void LvDevice::clear_pending_client_request_map ()
{
  TBFL_TRACE(device_name_);

  yat::MutexLock guard(pending_cl_rq_mtx_);

  TBFL_STDOUT("LvDevice::clear_pending_client_request_map["
              << device_name_
              << "] there is currently "
              << cl_rq_trash_.size()
              << " client request(s) in the trash");
              
  if ( pending_cl_rq_.empty() )
    return;
  
  ClientRequestMapIterator it = pending_cl_rq_.begin();
  for ( ; it != pending_cl_rq_.begin(); ++it )
  {
    delete it->second;
  }
  pending_cl_rq_.clear();
}

//=============================================================================
// LvDevice::empty_client_request_trash
//=============================================================================
void LvDevice::empty_client_request_trash ()
{
  TBFL_TRACE(device_name_);

  yat::MutexLock guard(cl_rq_trash_mtx_);

  TBFL_STDOUT("LvDevice::empty_client_request_trash["
              << device_name_
              << "] there is currently "
              << cl_rq_trash_.size()
              << " client request in the trash");
              
  if ( cl_rq_trash_.empty() )
    return;
  
  ClientRequestQueueIterator it = cl_rq_trash_.begin();
  for ( ; it != cl_rq_trash_.end(); ++it )
  {
    {
      //- be sure nobody is (still) using the client request...
      //-----------------------------------------------------------------------
      //- the implementation guarantee that nobody will try to access a given
      //- trashed client request after a successful lock of the associated mutex
      yat::MutexLock guard((*it)->mtx);
    }
    delete *it;
  }
  cl_rq_trash_.clear();
}

//=============================================================================
// LvDevice::interface
//=============================================================================
LvDeviceProxy* LvDevice::interface ()
{
  if ( ! tg_device_intf_ || interface_changed_ )
  {
    //- delete existing proxy
    delete tg_device_intf_;
    //- proxy to ourself to obtain attribute & command info compatible
    //- with the DataAdapter (here, we want to reuse the client part)
    //- TODO: write a LvDeviceProxy ctor accepting a xmi:Class as 2nd parameter
    tg_device_intf_ = new LvDeviceProxy(device_name_);
    // reset interface changed flag
    interface_changed_ = false;
  }

  return tg_device_intf_;
}

//=============================================================================
// LvDevice::log
//=============================================================================
void LvDevice::log (LoggingLevel level, const std::string& text)
{
  if ( device_impl_ )
  {
    device_impl_->log(level, text);
  }
}

//=============================================================================
// LvDevice::set_client_request_timeout
//=============================================================================
void LvDevice::set_client_request_timeout (double tmo_in_sec)
{
  TBFL_TRACE(device_name_);
  
  if ( tmo_in_sec < MIN_CLIENT_REQ_TMO_IN_SEC )
    tmo_in_sec = MIN_CLIENT_REQ_TMO_IN_SEC;
  else if ( tmo_in_sec > MAX_CLIENT_REQ_TMO_IN_SEC )
    tmo_in_sec = MAX_CLIENT_REQ_TMO_IN_SEC;
  
  cl_rq_ack_tmo_in_ms_ = static_cast<tbfl::uint32>(1000. * tmo_in_sec);

  TBFL_STDOUT("client request tmo for device "
              << device_name_
              << " is now "
              << cl_rq_ack_tmo_in_ms_
              << "ms");
}

//=============================================================================
// LvDevice::enable_state_machine
//=============================================================================
void LvDevice::enable_state_machine (bool enable)
{
  TBFL_TRACE(device_name_);
  
  state_machine_.enabled = enable; 
}

//=============================================================================
// LvDevice::abort_client_requests
//=============================================================================
void LvDevice::abort_client_requests ()
{
  //- CRITICAL SECTION
  yat::MutexLock guard(pending_cl_rq_mtx_);

  ClientRequestMapIterator it = pending_cl_rq_.begin();
  for ( ; it != pending_cl_rq_.end(); ++it )
  {
    if ( it->second )
    {
      TBFL_STDOUT("LvDevice::abort_client_requests::aborting request #"
                  << it->second->id
                  << ":"
                  << it->second->cmd_or_attr_name);
      {
        yat::MutexLock guard(it->second->mtx);
        it->second->state = CLIENT_REQ_STATE_ABORTED;
        it->second->cdt.signal();
      }
    }
  }
}

//=============================================================================
// LvDevice::dev_state
//=============================================================================
Tango::DevState LvDevice::dev_state ()
{
  TBFL_TRACE(device_name_);

  if ( ! enabled_ )
  {
    return Tango::UNKNOWN;
  }

  std::string attr_name("State");

  ClientRequest pcr(CLIENT_REQ_READ_ATTR, attr_name);
  wait_client_request_handled(pcr);

  LvClientRequestReplyDataBufferMapIterator it = rda_data_buffers_.find(attr_name);
  if ( it == rda_data_buffers_.end() || ! it->second.num_data )
  {
    std::ostringstream oss;
    oss << "LabVIEW device error: could not retrieve '"
        << attr_name
        << "' attribute value";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::dev_state"));
  }
  
  return static_cast<Tango::DevState>(*(reinterpret_cast<tbfl::uint32*>(it->second.num_data)));
}

//=============================================================================
// LvDevice::dev_status
//=============================================================================
std::string LvDevice::dev_status ()
{
  TBFL_TRACE(device_name_);

  if ( ! enabled_ )
  {
    return std::string("LabVIEW device is down");
  }

  std::string attr_name("Status");
  
  ClientRequest pcr(CLIENT_REQ_READ_ATTR, attr_name);
  wait_client_request_handled(pcr);

  LvClientRequestReplyDataBufferMapIterator it = rda_data_buffers_.find(attr_name);
  if ( it == rda_data_buffers_.end() || ! it->second.str_data || ! it->second.str_data[0] )
  {
    std::ostringstream oss;
    oss << "LabVIEW device error: could not retrieve '"
        << attr_name
        << "' attribute value";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::dev_state"));
  }

  return std::string(it->second.str_data[0]);
}

//=============================================================================
// LvDevice::add_dynamic_interface
//=============================================================================
void LvDevice::add_dynamic_interface ()
{
  TBFL_TRACE(device_name_);

  //- create dynamic interface
  if ( ! class_interface_ )
  {
    std::ostringstream oss;
    oss << "internal error: unexpected null pointer - failed to attach commands and attributes to device '"
        << device_name_
        << "'";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::add_dynamic_interface"));
  }

  //- instanciate the DynamicInterfaceManager on heap (due to the Tango kernel impl. of the "Restart Device" feature) 
  if ( ! dim_ )
  {
    try
    {
      dim_ = new yat4tango::DynamicInterfaceManager(device_impl_);
      if ( ! dim_ )
      {
        throw std::bad_alloc();
      }
    }
    catch ( ... )
    {
      Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                     _CPTC_("internal error: memory allocation failed [DynamicInterfaceManager instanciation failed]"),
                                     _CPTC_("LvDevice::add_dynamic_interface"));
    }
  }

  //- attach class attributes
  const std::vector<xmi::Attribute>& attributes = class_interface_->attributes;
  for ( size_t i = 0; i < attributes.size(); i++ )
  {
    yat4tango::DynamicAttributeInfo dai;
    dai.tai.name = "unknown-attribute";
    try
    {
      //-----------------------------------------
      const xmi::Attribute& a = attributes[i];
      TBFL_STDOUT("LvDevice::add_dynamic_interface:adding dynamic attribute " << a.name);
      //- excluded states -----------------------
      state_machine_.register_read_attribute_excluded_states(a.name, a.read_excluded_states);
      state_machine_.register_write_attribute_excluded_states(a.name, a.write_excluded_states);
      //- main properties -----------------------
      dai.dev = device_impl_;
      dai.cdb = false;
      dai.tai.name = a.name;
      dai.tai.data_format = a.att_type;
      dai.tai.data_type = a.data_type;
      dai.tai.writable = a.rw_type;
      dai.tai.disp_level = a.display_level;
      dai.tai.description = a.description;
      dai.tai.unit = a.unit;
      dai.tai.standard_unit = a.standard_unit;
      dai.tai.display_unit = a.display_unit;
      dai.tai.format = a.format;
      //- min/max -------------------------------
      dai.tai.min_value = a.min_value;
      dai.tai.max_value = a.max_value;
      //- alarms --------------------------------
      dai.tai.min_alarm = a.min_alarm;
      dai.tai.max_alarm = a.max_alarm;
      dai.tai.alarms.min_alarm = a.min_alarm;
      dai.tai.alarms.max_alarm = a.max_alarm;
      dai.tai.alarms.min_warning = a.min_warning;
      dai.tai.alarms.max_warning = a.max_warning;
      dai.tai.alarms.delta_t = a.delta_time;
      dai.tai.alarms.delta_val = a.delta_value;
      //- events --------------------------------
      for (tbfl::size_t e = 0; e < a.events.size(); e++)
      {
        switch (a.events[e].type)
        {
        case Tango::DATA_READY_EVENT:
          dai.data_ready_pushed_by_user_code = !a.events[e].fire;
          break;
        case Tango::CHANGE_EVENT:
          if (a.events[e].has_criteria)
          {
            dai.tai.events.per_event.period = a.events[e].criteria.period;
            dai.tai.events.ch_event.abs_change = a.events[e].criteria.abs_change;
            dai.tai.events.ch_event.rel_change = a.events[e].criteria.rel_change;
          }
          dai.change_evt_pushed_by_user_code = !a.events[e].fire;
          dai.change_evt_managed_by_user_code = !a.events[e].check_criteria;
          break;
        case Tango::ARCHIVE_EVENT:
          if (a.events[e].has_criteria)
          {
            dai.tai.events.arch_event.archive_period = a.events[e].criteria.period;
            dai.tai.events.arch_event.archive_abs_change = a.events[e].criteria.abs_change;
            dai.tai.events.arch_event.archive_rel_change = a.events[e].criteria.rel_change;
          }
          dai.archive_evt_pushed_by_user_code = !a.events[e].fire;
          dai.archive_evt_managed_by_user_code = !a.events[e].check_criteria;
          break;
        }
      }
      //- memorized -----------------------------
      dai.memorized = a.memorized;
      dai.write_memorized_value_at_init = a.memorized_at_init;
      //- enum labels ---------------------------
#if (TANGO_VERSION_MAJOR >= 9) 
      if ( Tango::DEV_ENUM == a.data_type )
      {
        dai.tai.enum_labels = a.enum_labels;
      }
#endif
      //- polling -------------------------------
      dai.polling_period_in_ms = a.polling_period;
      //- instanciate data buffer required to handle the read attr. request
      rda_data_buffers_[dai.tai.name] = LvClientRequestReplyDataBuffer();
      //- read & write callback (ok, write callback useless for read only attr, but not a big deal...)
      dai.rcb = yat4tango::DynamicAttributeReadCallback::instanciate(*this, &LvDevice::read_callback);
      dai.wcb = yat4tango::DynamicAttributeWriteCallback::instanciate(*this, &LvDevice::write_callback);
      //- attach dynamic attr to the device 
      dim_->dynamic_attributes_manager().add_attribute(dai);
      TBFL_STDOUT("LvDevice::add_dynamic_interface:dynamic attribute " << a.name << " successfully added");
    }
    catch (Tango::DevFailed& df)
    {
      std::ostringstream oss;
      oss << "failed to attach dynamic attribute '"
          << dai.tai.name
          << "' to Tango device '"
          << device_name_
          << "' [Tango exception caught - see log for details]";
      Tango::Except::re_throw_exception(df,
                                        _CPTC_("DEVICE_ERROR"),
                                        _CPTC_(oss.str().c_str()),
                                        _CPTC_("LvDevice::add_dynamic_interface"));
    }
    catch (...)
    {
      std::ostringstream oss;
      oss << "failed to attach dynamic attribute '"
          << dai.tai.name
          << "' to Tango device '"
          << device_name_
          << "' [unknown exception caught]";
      Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                      _CPTC_(oss.str().c_str()),
                                      _CPTC_("LvDevice::add_dynamic_interface"));
    }
  }

  //- attach commands
  const std::vector<xmi::Command>& commands = class_interface_->commands;
  for ( size_t i = 0; i < commands.size(); i++ )
  {
    yat4tango::DynamicCommandInfo dci;
    dci.tci.cmd_name = "unknown-command";
    try
    {
      const xmi::Command& c = commands[i];
      //- skip state & status
      if ( c.name == "Status" || c.name == "State" )
        continue;
      //- excluded states -----------------------
      state_machine_.register_execute_command_excluded_states(c.name, c.excluded_states);
      //- main properties -----------------------
      dci.dev = device_impl_;
      dci.tci.cmd_name = c.name;
      dci.tci.in_type  = c.argin.type;
      dci.tci.out_type = c.argout.type;
      dci.tci.disp_level = c.display_level;
      //- instanciate data buffer required to handle the exec. command request
      exc_data_buffers_[dci.tci.cmd_name] = LvClientRequestReplyDataBuffer();
      //- execute callback 
      dci.ecb = yat4tango::DynamicCommandExecuteCallback::instanciate(*this, &LvDevice::execute_callback);
      //- attach dynamic command to the device 
      dim_->dynamic_commands_manager().add_command(dci);
    }
    catch (Tango::DevFailed& df)
    {
      std::ostringstream oss;
      oss << "failed to attach dynamic command '"
          << dci.tci.cmd_name
          << "' to Tango device '"
          << device_name_
          << "' [Tango exception caught - see log for details]";
      Tango::Except::re_throw_exception(df,
                                        _CPTC_("DEVICE_ERROR"),
                                        _CPTC_(oss.str().c_str()),
                                        _CPTC_("LvDevice::add_dynamic_interface"));
    }
    catch (...)
    {
      std::ostringstream oss;
      oss << "failed to attach dynamic command '"
          << dci.tci.cmd_name
          << "' to Tango device '"
          << device_name_
          << "' [unknown exception caught]";
      Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                     _CPTC_(oss.str().c_str()),
                                     _CPTC_("LvDevice::add_dynamic_interface"));
    }
  }

}

//=============================================================================
// LvDevice::remove_dynamic_interface
//=============================================================================
void LvDevice::remove_dynamic_interface ()
{
  TBFL_TRACE(device_name_);
  
  try
  {
    if ( dim_ )
    {
      dim_->remove();
    }
  }
  catch ( Tango::DevFailed& df )
  {
    std::ostringstream oss;
    oss << "Tango exception caught while trying to remove dynamic interface on device "
        << device_name_;
    Tango::Except::re_throw_exception(df,
                                      _CPTC_("DEVICE_ERROR"),
                                      _CPTC_(oss.str().c_str()),
                                      _CPTC_("LvDevice::remove_dynamic_interface"));
  }
  catch ( ... )
  {
    std::ostringstream oss;
    oss << "unknown exception caught while trying to remove dynamic interface on device "
        << device_name_;
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::remove_dynamic_interface"));
  }
}

//=============================================================================
// LvDevice::reload_dynamic_interface
//=============================================================================
void LvDevice::reload_dynamic_interface ()
{
  TBFL_TRACE(device_name_);

  remove_dynamic_interface();

  add_dynamic_interface();

  interface_changed_ = true;
}

//----------------------------------------------------------------------------------------
// void LvDevice::execute_callback
//----------------------------------------------------------------------------------------
void LvDevice::execute_callback (yat4tango::DynamicCommandExecuteCallbackData& cbd)
{
  TBFL_TRACE(device_name_);

  //- note: Tango impl. guarantee that the device monitor is locked

  if ( ! cbd.dyc )
  {
    THROW_DEVFAILED("INTERNAL_ERROR",
                    "unexpected NULL pointer to dynamic command",
                    "LvDevice::execute_callback");
  }

  if ( ! enabled_ )
  {
    std::ostringstream oss;
    oss << "LabVIEW device is down [command "
        <<  cbd.dyc->get_name()
        << " aborted]";
    THROW_DEVFAILED("LABVIEW_DEVICE_ERROR",
                    oss.str().c_str(),
                    "LvDevice::execute_callback");
  }

  if ( state_machine_.enabled )
  {
    Tango::DevState s = dev_state();

    if ( ! state_machine_.is_command_allowed(cbd.dyc->get_name(), s) )
    {
      std::ostringstream oss;
      oss << "the current device state does not allow to execute the '"
          <<  cbd.dyc->get_name()
          << "' command [current state is: "
          << Tango::DevStateName[s]
          << "]";
      THROW_DEVFAILED("LABVIEW_DEVICE_ERROR",
                      oss.str().c_str(),
                      "LvDevice::execute_callback");
    }
  }

  TBFL_STDOUT("Device::execute_callback:handling execute request for dynamic command: "
              << cbd.dyc->get_name());

  ClientRequest pcr;
  pcr.type = CLIENT_REQ_EXEC_CMD;
  pcr.cmd_or_attr_name = cbd.dyc->get_name();

  LvClientRequest crn;
  intialize_client_request_notification(pcr, crn);
  
  try
  {
    const CommandInfo& ci = interface()->command_info(pcr.cmd_or_attr_name);
        
    DATA_ADAPTER->copy_tg_argin(ci, cbd.dyc, &crn.data.eca);
  }
  catch (Tango::DevFailed& df)
  {
    std::ostringstream oss;
    oss << "Tango exception caught while trying to bufferize write value for attribute "
        << cbd.dyc->get_name();   
    Tango::Except::re_throw_exception(df,
                                      _CPTC_("DEVICE_ERROR"),
                                      _CPTC_(oss.str().c_str()),
                                      _CPTC_("LvDevice::execute_callback"));
  }
  catch (...)
  {
    std::ostringstream oss;
    oss << "Unknown exception caught while trying to bufferize write value for attribute "
        << cbd.dyc->get_name();   
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::execute_callback"));
  }
  
  wait_client_request_handled(pcr, crn);
   
  if (  cbd.dyc->get_tango_data_type(yat4tango::ARGOUT) == Tango::DEV_VOID )
    return;

  TBFL_STDOUT("LvDevice::execute_callback: returning argout for command: "
              << cbd.dyc->get_name());
              
  LvClientRequestReplyDataBuffer& eb = exc_data_buffers_[cbd.dyc->get_name()];

  if ( ! eb.num_data )
  {
    std::ostringstream oss;
    oss << "LabVIEW device error: failed to execute command '"
        <<  cbd.dyc->get_name()
        << "' [data conversion failed - unexpected null pointer to data buffer]";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::execute_callback"));
  }

  //- set cmd argout
  try 
  {
    switch ( cbd.dyc->get_tango_data_type(yat4tango::ARGOUT) )
    {
      case Tango::DEV_STATE:
        cbd.dyc->set_argout(eb.get_tango_scalar<Tango::DevState>());
        eb.release();
        break;
      case Tango::DEV_BOOLEAN:
        cbd.dyc->set_argout(eb.get_tango_scalar<Tango::DevBoolean>());
        eb.release();
        break;
#if (TANGO_VERSION_MAJOR >= 9) 
	    case Tango::DEV_ENUM:
#endif
      case Tango::DEV_SHORT:
        cbd.dyc->set_argout(eb.get_tango_scalar<Tango::DevShort>());
        eb.release();
        break;
      case Tango::DEV_USHORT:
        cbd.dyc->set_argout(eb.get_tango_scalar<Tango::DevUShort>());
        eb.release();
        break;
      case Tango::DEV_LONG:
        cbd.dyc->set_argout(eb.get_tango_scalar<Tango::DevLong>());
        eb.release();
        break;
      case Tango::DEV_ULONG:
        cbd.dyc->set_argout(eb.get_tango_scalar<Tango::DevULong>());
        eb.release();
        break;
      case Tango::DEV_LONG64:
        cbd.dyc->set_argout(eb.get_tango_scalar<Tango::DevLong64>());
        eb.release();
        break;
      case Tango::DEV_ULONG64:
        cbd.dyc->set_argout(eb.get_tango_scalar<Tango::DevULong64>());
        eb.release();
        break;
      case Tango::DEV_FLOAT:
        cbd.dyc->set_argout(eb.get_tango_scalar<Tango::DevFloat>());
        eb.release();
        break;
      case Tango::DEV_DOUBLE:
        cbd.dyc->set_argout(eb.get_tango_scalar<Tango::DevDouble>());
        eb.release();
        break;
      case Tango::DEV_STRING:
        cbd.dyc->set_argout(eb.get_tango_string());
        eb.detach_data();
        break;
      case Tango::DEVVAR_CHARARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarCharArray>());
        eb.detach_data();
        break;
      case Tango::DEVVAR_SHORTARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarShortArray>());
        eb.detach_data();
        break;
      case Tango::DEVVAR_USHORTARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarUShortArray>());
        eb.detach_data();
        break;
      case Tango::DEVVAR_LONGARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarLongArray>());
        eb.detach_data();
        break;
      case Tango::DEVVAR_ULONGARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarULongArray>());
        eb.detach_data();
        break;
      case Tango::DEVVAR_LONG64ARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarLong64Array>());
        eb.detach_data();
        break;
      case Tango::DEVVAR_ULONG64ARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarULong64Array>());
        eb.detach_data();
        break;
      case Tango::DEVVAR_FLOATARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarFloatArray>());
        eb.detach_data();
        break;
      case Tango::DEVVAR_DOUBLEARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarDoubleArray>());
        eb.detach_data();
        break;
      case Tango::DEVVAR_STRINGARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarStringArray>());
        eb.detach_data();
        break;
      case Tango::DEVVAR_LONGSTRINGARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarLongStringArray>());
        eb.detach_data();
        break;
      case Tango::DEVVAR_DOUBLESTRINGARRAY:
        cbd.dyc->set_argout(eb.get_tango_array<Tango::DevVarDoubleStringArray>());
        eb.detach_data();
        break;
      default:
      {
        eb.release();
        std::ostringstream oss;
        oss << "LabVIEW device error: command '"
            <<  cbd.dyc->get_name()
            << "' has an unsupported data type!";
        Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                       _CPTC_(oss.str().c_str()),
                                       _CPTC_("LvDevice::execute_callback"));
      }
      break;
    }
  }
  catch (Tango::DevFailed& df)
  {
    _BEST_EFFORT_TRY_(eb.release());
    std::ostringstream oss;
    oss << "LabVIEW device error: failed to execute command '"
        <<  cbd.dyc->get_name()
        << "' [Tango exception caught]";
    Tango::Except::re_throw_exception(df,
                                      _CPTC_("DEVICE_ERROR"),
                                      _CPTC_(oss.str().c_str()),
                                      _CPTC_("LvDevice::execute_callback"));
  }
  catch (...)
  {
    _BEST_EFFORT_TRY_(eb.release());
    std::ostringstream oss;
    oss << "LabVIEW device error: failed to execute command '"
        <<  cbd.dyc->get_name()
        << "' [unknown exception caught]";
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::execute_callback"));
  }
}

//----------------------------------------------------------------------------------------
// NUM_READ_TMPL_CASE
//----------------------------------------------------------------------------------------
#define NUM_READ_TMPL_CASE(TYPE_ID, TYPE) \
  case TYPE_ID: \
  { \
    if ( ! rb.num_data ) \
    { \
      std::ostringstream oss; \
      oss << "LabVIEW device error: could not retrieve '" \
          <<  cbd.dya->get_name() \
          << "' attribute value"; \
      Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"), \
                                     _CPTC_(oss.str().c_str()), \
                                     _CPTC_("LvDevice::read_callback")); \
    } \
    TYPE *p = reinterpret_cast<TYPE*>(rb.num_data); \
    cbd.tga->set_value(p, rb.dim_x, rb.dim_y); \
  } \
  break;

//----------------------------------------------------------------------------------------
// STR_READ_TMPL_CASE
//----------------------------------------------------------------------------------------
#define STR_READ_TMPL_CASE(TYPE_ID, TYPE) \
  case TYPE_ID: \
  { \
    if ( ! rb.str_data ) \
    { \
      std::ostringstream oss; \
      oss << "LabVIEW device error: could not retrieve '" \
          <<  cbd.dya->get_name() \
          << "' attribute value"; \
      Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"), \
                                     _CPTC_(oss.str().c_str()), \
                                     _CPTC_("LvDevice::read_callback")); \
    } \
    TYPE *p = reinterpret_cast<TYPE*>(rb.str_data); \
    cbd.tga->set_value(p, rb.dim_x, rb.dim_y); \
  } \
  break;
  
//----------------------------------------------------------------------------------------
// void LvDevice::read_callback
//----------------------------------------------------------------------------------------
void LvDevice::read_callback (yat4tango::DynamicAttributeReadCallbackData& cbd)
{
  TBFL_TRACE(device_name_);

  //- note: Tango impl. guarantee that the device monitor is locked

  if ( ! cbd.dya )
  {
    THROW_DEVFAILED("INTERNAL_ERROR",
                    "unexpected NULL pointer to dynamic attribute",
                    "LvDevice::read_callback");
  }
  
  if ( ! enabled_ )
  {
    std::ostringstream oss;
    oss << "LabVIEW device is down [read "
        << cbd.dya->get_name()
        << " aborted]";
    THROW_DEVFAILED("LABVIEW_DEVICE_ERROR",
                    oss.str().c_str(),
                    "LvDevice::read_callback");
  }

  if ( state_machine_.enabled )
  {
    Tango::DevState s = dev_state();

    if ( ! state_machine_.is_read_attribute_allowed(cbd.dya->get_name(), s) )
    {
      std::ostringstream oss;
      oss << "the current device state does not allow to read the '"
          << cbd.dya->get_name()
          << "' attribute [current state is: "
          << Tango::DevStateName[s]
          << "]";
      THROW_DEVFAILED("LABVIEW_DEVICE_ERROR",
                      oss.str().c_str(),
                      "LvDevice::read_callback");
    }
  }

  TBFL_STDOUT("LvDevice::read_callback: handling read request for dynamic attribute: "
              << cbd.dya->get_name());

  ClientRequest pcr;
  pcr.type = CLIENT_REQ_READ_ATTR;
  pcr.cmd_or_attr_name = cbd.dya->get_name();
  wait_client_request_handled(pcr);

  TBFL_STDOUT("LvDevice::read_callback: returning value for attribute: "
              << cbd.dya->get_name());

  LvClientRequestReplyDataBuffer& rb = rda_data_buffers_[cbd.dya->get_name()];

  switch ( cbd.dya->get_tango_data_type() )
  {
    NUM_READ_TMPL_CASE(Tango::DEV_STATE,   Tango::DevState);
    NUM_READ_TMPL_CASE(Tango::DEV_BOOLEAN, Tango::DevBoolean);
    NUM_READ_TMPL_CASE(Tango::DEV_UCHAR,   Tango::DevUChar);
    NUM_READ_TMPL_CASE(Tango::DEV_USHORT,  Tango::DevUShort);
    NUM_READ_TMPL_CASE(Tango::DEV_SHORT,   Tango::DevShort);
    NUM_READ_TMPL_CASE(Tango::DEV_LONG,    Tango::DevLong);
    NUM_READ_TMPL_CASE(Tango::DEV_ULONG,   Tango::DevULong);
    NUM_READ_TMPL_CASE(Tango::DEV_LONG64,  Tango::DevLong64);
    NUM_READ_TMPL_CASE(Tango::DEV_ULONG64, Tango::DevULong64);
    NUM_READ_TMPL_CASE(Tango::DEV_FLOAT,   Tango::DevFloat);
    NUM_READ_TMPL_CASE(Tango::DEV_DOUBLE,  Tango::DevDouble);
    STR_READ_TMPL_CASE(Tango::DEV_STRING,  Tango::DevString);
#if (TANGO_VERSION_MAJOR >= 9) 
    NUM_READ_TMPL_CASE(Tango::DEV_ENUM,    Tango::DevShort);
#endif
    default:
    {
      std::ostringstream oss;
      oss << "LabVIEW device error: attribute '"
          <<  cbd.dya->get_name()
          << "' has an unsupported data type!";
      Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                     _CPTC_(oss.str().c_str()),
                                     _CPTC_("LvDevice::read_callback"));
    }
    break;
  }
}

//----------------------------------------------------------------------------------------
// void LvDevice::write_callback
//----------------------------------------------------------------------------------------
void LvDevice::write_callback (yat4tango::DynamicAttributeWriteCallbackData& cbd)
{
  TBFL_TRACE(device_name_);

  //- note: Tango impl. guarantee that the device monitor is locked

  if ( ! cbd.dya )
  {
    THROW_DEVFAILED("INTERNAL_ERROR",
                    "unexpected NULL pointer to dynamic attribute",
                    "LvDevice::write_callback");
  }

  if ( ! enabled_ )
  {
    std::ostringstream oss;
    oss << "LabVIEW device is down [write "
        << cbd.dya->get_name()
        << " aborted]";
    THROW_DEVFAILED("LABVIEW_DEVICE_ERROR",
                    oss.str().c_str(),
                    "LvDevice::write_callback");
  }

  if ( state_machine_.enabled )
  {
    Tango::DevState s = dev_state();

    if ( ! state_machine_.is_write_attribute_allowed(cbd.dya->get_name(), s) )
    {
      std::ostringstream oss;
      oss << "the current device state does not allow to write the '"
          << cbd.dya->get_name()
          << "' attribute [current state is: "
          << Tango::DevStateName[s]
          << "]";
      THROW_DEVFAILED("LABVIEW_DEVICE_ERROR",
                      oss.str().c_str(),
                      "LvDevice::write_callback");
    }
  }

  TBFL_STDOUT("LvDevice::write_callback: handling write request for dynamic attribute: "
              << cbd.dya->get_name());

  ClientRequest pcr;
  pcr.type = CLIENT_REQ_WRITE_ATTR;
  pcr.cmd_or_attr_name = cbd.tga->get_name();

  LvClientRequest crn;
  intialize_client_request_notification(pcr, crn);
  
  try
  {
    DATA_ADAPTER->copy_tg_attr_value(*cbd.tga, crn);
  }
  catch (Tango::DevFailed& df)
  {
    std::ostringstream oss;
    oss << "Tango exception caught while trying to bufferize write value for attribute "
        << cbd.tga->get_name();   
    Tango::Except::re_throw_exception(df,
                                      _CPTC_("DEVICE_ERROR"),
                                      _CPTC_(oss.str().c_str()),
                                      _CPTC_("LvDevice::write_callback"));
  }
  catch (...)
  {
    std::ostringstream oss;
    oss << "Unknown exception caught while trying to bufferize write value for attribute "
        << cbd.tga->get_name();   
    Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::write_callback"));
  }
  
  wait_client_request_handled(pcr, crn);
}

//=============================================================================
// LvDevice::intialize_client_request_notification
//=============================================================================
void LvDevice::intialize_client_request_notification (ClientRequest& pcr, LvClientRequest& crn)
    throw (Tango::DevFailed)
{  
  //- set request identifier
  crn.request_id = ++client_request_cnt_ % 0xFFFFFFFF;

  //- set event source identifier
  crn.source_id = lv_evt_source_id_;
  
  //- set request type
  crn.request_type = static_cast<tbfl::uint16>(pcr.type);

  //- set device name
  tbfl::size_t l = static_cast<tbfl::size_t>(device_name_.size());
  MgErr err = ::NumericArrayResize(iB, 1L, (UHandle*)&(crn.device_name), l);
  if ( err != noErr )
  {
    std::ostringstream oss;
    oss << "client request failed for "
        << device_name_
        << "/"
        << pcr.cmd_or_attr_name
        << " [request type was: '"
        << request_type_str(pcr.type)
        << "'] [memory allocation failed]";
    Tango::Except::throw_exception(_CPTC_("memory error"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::intialize_client_request_notification"));
  }
  (*crn.device_name)->length = l;
  ::memcpy((*crn.device_name)->data, device_name_.c_str(), l);

  //- set class name
  l = static_cast<tbfl::size_t>(original_class_name_.size());
  err = ::NumericArrayResize(iB, 1L, (UHandle*)&(crn.class_name), l);
  if ( err != noErr )
  {
    std::ostringstream oss;
    oss << "client request failed for "
        << device_name_
        << "/"
        << pcr.cmd_or_attr_name
        << " [request type was: '"
        << request_type_str(pcr.type)
        << "'] [memory allocation failed]";
    Tango::Except::throw_exception(_CPTC_("memory error"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::intialize_client_request_notification"));
  }
  (*crn.class_name)->length = l;
  ::memcpy((*crn.class_name)->data, original_class_name_.c_str(), l);
  
  //- set command or attribute name
  l = static_cast<tbfl::size_t>(pcr.cmd_or_attr_name.size());
  err = ::NumericArrayResize(iB, 1L, (UHandle*)&(crn.cmd_or_attr_name), l);
  if ( err != noErr )
  {
    std::ostringstream oss;
    oss << "client request failed for "
        << device_name_
        << "/"
        << pcr.cmd_or_attr_name
        << " [request type was: '"
        << request_type_str(pcr.type)
        << "'] [memory allocation failed]";
    Tango::Except::throw_exception(_CPTC_("memory error"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::intialize_client_request_notification"));
  }
  (*crn.cmd_or_attr_name)->length = l;
  ::memcpy((*crn.cmd_or_attr_name)->data, pcr.cmd_or_attr_name.c_str(), l);
}

//=============================================================================
// LvDevice::post_lv_user_event
//=============================================================================
void LvDevice::post_lv_user_event (LvClientRequest& crn)
    throw (Tango::DevFailed)
{
  //- important note: PostLVUserEvent makes a deep copy of the data!
  MgErr mg_err = ::PostLVUserEvent(lv_evt_ref_, static_cast<void*>(&crn));
  if ( mg_err != noErr )
  {
    std::string cmd_or_attr_name;
    DATA_ADAPTER->to_std_str(crn.cmd_or_attr_name, cmd_or_attr_name);
    std::ostringstream oss;
    oss << "failed to post '"
        << request_type_label(static_cast<LvClientRequestType>(crn.request_type))
        << "' notification to "
        << device_name_
        << "/"
        << cmd_or_attr_name
        << " [the LabVIEW device is certainly down]";
    TBFL_STDOUT(oss.str());
    Tango::Except::throw_exception(_CPTC_("internal error"),
                                   _CPTC_(oss.str().c_str()),
                                   _CPTC_("LvDevice::post_lv_user_event"));
  }
}

//=============================================================================
// _MOVE_PCR_TO_TRASH_
//=============================================================================
#define _MOVE_PCR_TO_TRASH_ \
  { \
    yat::MutexLock guard(pending_cl_rq_mtx_); \
    { \
      yat::MutexLock guard(cl_rq_trash_mtx_); \
      cl_rq_trash_.push_back(pcr); \
    } \
    pending_cl_rq_.erase(pcr->id); \
  }
  
//=============================================================================
// LvDevice::post_client_request
//=============================================================================
void LvDevice::post_client_request (ClientRequest& in_pcr)
    throw (Tango::DevFailed)
{
  LvClientRequest crn;
  intialize_client_request_notification(in_pcr, crn);
  
  ClientRequest* pcr = new ClientRequest(in_pcr);
  pcr->id = crn.request_id;
  pcr->state = CLIENT_REQ_STATE_PENDING_ASYNC;

  //- push client request into the repository
  { //- CRITICAL SECTION
    yat::MutexLock guard(pending_cl_rq_mtx_);
    pending_cl_rq_[pcr->id] = pcr;
  } //- CRITICAL SECTION

  //- post client request to LabVIEW
  try
  {
    post_lv_user_event(crn);
  }
  catch ( ... )
  {
    //- PostLVUserEvent failed - consequently, the last request in queue will never be
    //- 'seen/handled/...' by the labview side of the device impl - we can safely remove
    //- it from the the pending request repository (std::dqueue)
    _MOVE_PCR_TO_TRASH_;
    throw;
  }
}
    
//=============================================================================
// LvDevice::wait_client_request_handled
//=============================================================================
void LvDevice::wait_client_request_handled (ClientRequest& in_pcr)
    throw (Tango::DevFailed)
{
  LvClientRequest crn;
  intialize_client_request_notification(in_pcr, crn);
  
  wait_client_request_handled(in_pcr, crn);
}

//=============================================================================
// LvDevice::wait_client_request_handled
//=============================================================================
void LvDevice::wait_client_request_handled (ClientRequest& in_pcr, LvClientRequest& crn)
    throw (Tango::DevFailed)
{
  ClientRequest* pcr = new ClientRequest(in_pcr);
  pcr->id = crn.request_id;
  pcr->state = CLIENT_REQ_STATE_PENDING_SYNC;

  //- push client request into the repository
  { //- CRITICAL SECTION
    yat::MutexLock guard(pending_cl_rq_mtx_);
    pending_cl_rq_[pcr->id] = pcr;
  } //- CRITICAL SECTION

  //- post client request to LabVIEW
  try
  {
    post_lv_user_event(crn);
  }
  catch ( ... )
  {
    //- PostLVUserEvent failed - consequently, the last request in queue will never be
    //- 'seen/handled/...' by the labview side of the device impl - we can safely remove
    //- it from the the pending request repository (std::dqueue)
    _MOVE_PCR_TO_TRASH_;
    throw;
  }

  //- wait for the client request to be handled on labview side

  { //- CRITICAL SECTION
    yat::MutexLock guard(pcr->mtx);

    while ( pcr->pending() )
    {
      if ( ! pcr->cdt.timed_wait(cl_rq_ack_tmo_in_ms_) && pcr->pending() )
      {
        pcr->state = CLIENT_REQ_STATE_EXPIRED;
        std::ostringstream oss;
        oss << "timeout expired while waiting for client request to be handled on LabVIEW side: "
            << device_name_
            << ":"
            << pcr->cmd_or_attr_name
            << " [req. was #"
            << pcr->id
            << ":"
            << request_type_str(pcr->type)
            << "]";
        TBFL_STDOUT(oss.str());
        _MOVE_PCR_TO_TRASH_;
        Tango::Except::throw_exception(_CPTC_("TIMEOUT_EXPIRED"),
                                       _CPTC_(oss.str().c_str()),
                                       _CPTC_("LvDevice::wait_client_request_handled"));
      }
    }

    //- request failed?
    if ( pcr->state == CLIENT_REQ_STATE_FAILED )
    {
      _MOVE_PCR_TO_TRASH_;
      throw_client_request_error(*pcr);
    }
    //- request aborted?
    else if ( pcr->state == CLIENT_REQ_STATE_ABORTED )
    {
      std::ostringstream oss;
      oss << "client request aborted for "
          << device_name_
          << "/"
          << pcr->cmd_or_attr_name
          << " [request type was: '"
          << request_type_str(pcr->type)
          << "'] [the LabVIEW device is certainly exiting]";
      TBFL_STDOUT(oss.str());
      _MOVE_PCR_TO_TRASH_;
      Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                     _CPTC_(oss.str().c_str()),
                                     _CPTC_("LvDevice::wait_client_request_handled"));
    }
    else if ( pcr->state == CLIENT_REQ_STATE_HANDLED )
    {
      _MOVE_PCR_TO_TRASH_;
    }
    else
    {
      std::ostringstream oss;
      oss << "client request handling error for "
          << device_name_
          << "/"
          << pcr->cmd_or_attr_name
          << " [request type was: '"
          << request_type_str(pcr->type)
          << "'] [unknown error]";
      _MOVE_PCR_TO_TRASH_;
      Tango::Except::throw_exception(_CPTC_("DEVICE_ERROR"),
                                     _CPTC_(oss.str().c_str()),
                                     _CPTC_("LvDevice::wait_client_request_handled"));
    }
  } //- CRITICAL SECTION
}

//=============================================================================
// LvDevice:::throw_client_request_error
//=============================================================================
void LvDevice::throw_client_request_error (ClientRequest& pcr)
    throw (Tango::DevFailed)
{
  std::ostringstream oss;

  switch ( pcr.type )
  {
    case CLIENT_REQ_EXEC_CMD:
      oss << "failed to execute command ";
      break;
    case CLIENT_REQ_READ_ATTR:
      oss << "failed to read attribute ";
      break;
    case CLIENT_REQ_WRITE_ATTR:
      oss << "failed to write attribute ";
      break;
    default:
      oss << "unknown request gave error for ";
      break;
  }

  oss << pcr.cmd_or_attr_name
      << " on LabVIEW device "
      << device_name_;

  Tango::Except::re_throw_exception(pcr.error,
                                    _CPTC_("LABVIEW_DEVICE_ERROR"),
                                    _CPTC_(oss.str().c_str()),
                                    _CPTC_("LvDevice::wait_client_request_handled"));
}
 
//=============================================================================
// LvDevice::set_execute_command_argout
//=============================================================================
void LvDevice::set_execute_command_argout (LvExecuteCommandReplyPtr ecr)
    throw (Tango::DevFailed)
{
  ClientRequest* pcr = 0;
  
  { //- CRITICAL SECTION
    yat::MutexLock guard(pending_cl_rq_mtx_);

    if ( pending_cl_rq_.empty() )
    {
      TBFL_STDOUT("LvDevice::set_exec_cmd_argout::request repository is empty! aborting...");
      return;
    }

    //- search the request in the pending requests repository
    ClientRequestMapIterator it = pending_cl_rq_.find(ecr->ack.request_id);
    if ( it == pending_cl_rq_.end() )
    {
      //- request not found! it certainly timedout and has been trashed by caller thread
      TBFL_STDOUT("LvDevice::ecr::request #"
                  << ecr->ack.request_id
                  << " timedout [could not be found in the pending requests repository] - aborting...");
      return;
    }

    //- ok, request found
    pcr = it->second;
  } //- CRITICAL SECTION

  { //- CRITICAL SECTION
    yat::MutexLock guard(pcr->mtx);
    
    if ( pcr->state == CLIENT_REQ_STATE_PENDING_ASYNC )
    {
      //- waiter has leaved the place on timeout
      TBFL_STDOUT("LvDevice::set_exec_cmd_argout::request #"
                  << pcr->id
                  << " is asynchronous [client thread leaved the place] - removing it from repository");
      //- remove request from repository then simply (and silently) return
      _MOVE_PCR_TO_TRASH_;
      return;
    }
    else if ( pcr->state == CLIENT_REQ_STATE_EXPIRED )
    {
      //- waiter has leaved the place on timeout
      TBFL_STDOUT("LvDevice::set_exec_cmd_argout::timeout expired for request #"
                  << pcr->id
                  << " - removing it from repository [that's weird cause we should never see any expired request here!]");
      //- remove request from repository then simply (and silently) return
      _MOVE_PCR_TO_TRASH_;
      return;
    }

    //- the data buffer associated with the request
    LvClientRequestReplyDataBuffer& cb = exc_data_buffers_[pcr->cmd_or_attr_name];

    //- copy argout data
    if ( ! ecr->ack.error_code )
    {
      try
      {
        const CommandInfo& ci = interface()->command_info(pcr->cmd_or_attr_name);
        
        DATA_ADAPTER->copy_lv_argout(ci, &ecr->argout, cb);
      }
      catch (Tango::DevFailed& df)
      {
        TBFL_STDOUT("Tango exception caught while trying to bufferize the attribute value for "
                    << pcr->cmd_or_attr_name);
        //- tell waiter that the request failed
        pcr->state = CLIENT_REQ_STATE_FAILED;
        pcr->error = df;
        pcr->cdt.signal();
        return; 
      }
      catch (...)
      {
        TBFL_STDOUT("unknown exception caught while trying to bufferize the attribute value for "
                    << pcr->cmd_or_attr_name);
        //- tell waiter that the request failed
        pcr->state = CLIENT_REQ_STATE_FAILED;
        pcr->error = ERROR_STACK->devfailed("unknown exception caught while trying to bufferize the attribute value [internal error]");
        pcr->cdt.signal();
        return;
      }
      //- mark client request has properly handled
      pcr->state = CLIENT_REQ_STATE_HANDLED;
    }
    //- copy error stack
    else if ( ecr->ack.error_code )
    {
      //- client request failed
      TBFL_STDOUT("LvDevice::set_exec_cmd_argout::request #"
                  << pcr->id
                  << " failed!");
      pcr->state = CLIENT_REQ_STATE_FAILED;
      pcr->error = ERROR_STACK->devfailed(ecr->ack.error_stack);
    }
    //- notify waiter...
    pcr->cdt.signal();
  } //- CRITICAL SECTION
}

//=============================================================================
// LvDevice::set_read_attr_value
//=============================================================================
void LvDevice::set_read_attribute_value (LvReadAttributeReplyPtr rar)
    throw (Tango::DevFailed)
{
  
  ClientRequest* pcr = 0;
  
  { //- CRITICAL SECTION
    yat::MutexLock guard(pending_cl_rq_mtx_);

    if ( pending_cl_rq_.empty() )
    {
      TBFL_STDOUT("LvDevice::set_read_attribute_value::request repository is empty! aborting...");
      return;
    }

    //- search the request in the pending requests repository
    ClientRequestMapIterator it = pending_cl_rq_.find(rar->ack.request_id);
    if ( it == pending_cl_rq_.end() )
    {
      //- request not found! it certainly timedout and has been trashed by caller thread
      TBFL_STDOUT("LvDevice::set_read_attribute_value::request #"
                  << rar->ack.request_id
                  << " timedout [could not be found in the pending requests repository] - aborting...");
      return;
    }
    
    //- ok, request found
    pcr = it->second;
  } //- CRITICAL SECTION
  
  { //- CRITICAL SECTION
    yat::MutexLock guard(pcr->mtx);
                
    if ( pcr->state == CLIENT_REQ_STATE_PENDING_ASYNC )
    {
      //- waiter has leaved the place on timeout
      TBFL_STDOUT("LvDevice::set_read_attribute_value::request #"
                  << pcr->id
                  << " is asynchronous [client thread leaved the place] - removing it from repository");
      //- remove request from repository then simply (and silently) return
      _MOVE_PCR_TO_TRASH_;
      return;
    }
    else if ( pcr->state == CLIENT_REQ_STATE_EXPIRED )
    {
      //- waiter has leaved the place on timeout
      TBFL_STDOUT("LvDevice::set_read_attribute_value::timeout expired for request #"
                  << pcr->id
                  << " - removing it from repository [that's weird cause we should never see any expired request here!]");
      //- remove request from repository then simply (and silently) return
      _MOVE_PCR_TO_TRASH_;
      return;
    }

    //- the data buffer associated with the request
    LvClientRequestReplyDataBuffer& rb = rda_data_buffers_[pcr->cmd_or_attr_name];
    rb.release();

    //- copy attribute data
    if ( ! rar->ack.error_code )
    {
      try
      {
        const AttributeInfo& ai = interface()->attribute_info(pcr->cmd_or_attr_name);
        
        DATA_ADAPTER->copy_lv_attr_value(ai, &rar->val, rb);
      }
      catch (Tango::DevFailed& df)
      {
        TBFL_STDOUT("Tango exception caught while trying to bufferize the attribute value for "
                    << pcr->cmd_or_attr_name);
        //- tell waiter that the request failed
        pcr->state = CLIENT_REQ_STATE_FAILED;
        pcr->error = df;
        pcr->cdt.signal();
        return; 
      }
      catch (...)
      {
        TBFL_STDOUT("unknown exception caught while trying to bufferize the attribute value for "
                    << pcr->cmd_or_attr_name);
        //- tell waiter that the request failed
        pcr->state = CLIENT_REQ_STATE_FAILED;
        pcr->error = ERROR_STACK->devfailed("unknown exception caught while trying to bufferize the attribute value [internal error]");
        pcr->cdt.signal();
        return;
      }
      //- mark client request has properly handled
      pcr->state = CLIENT_REQ_STATE_HANDLED;
    }
    //- copy error stack
    else
    {
      //- client request failed
      pcr->state = CLIENT_REQ_STATE_FAILED;
      pcr->error = ERROR_STACK->devfailed(rar->ack.error_stack);
    }
    //- notify waiter...
    TBFL_STDOUT("LvDevice::set_read_attribute_value::notifying waiter for request #"
                << pcr->id
                << ":"
                << pcr->cmd_or_attr_name);
    pcr->cdt.signal();
  } //- CRITICAL SECTION
}

//=============================================================================
// LvDevice::ack_client_request
//=============================================================================
void LvDevice::ack_client_request (LvClientRequestReplyPtr _cl_rq_ack)
    throw (Tango::DevFailed)
{   
  ClientRequest* pcr = 0;
  
  { //- CRITICAL SECTION
    yat::MutexLock guard(pending_cl_rq_mtx_);

    if ( pending_cl_rq_.empty() )
    {
      //- nothing to do, simply (and silently) return
      TBFL_STDOUT("LvDevice::ack_client_request::request repository is empty! aborting...");
      return;
    }

    //- search the request in the pending requests repository
    ClientRequestMapIterator it = pending_cl_rq_.find(_cl_rq_ack->request_id);
    if ( it == pending_cl_rq_.end() )
    {
      //- request not found! it certainly timedout and has been trashed by caller thread
      TBFL_STDOUT("LvDevice::ack_client_request::request #"
                  << _cl_rq_ack->request_id
                  << " timedout [could not be found in the pending requests repository] - aborting...");
      return;
    }

    //- ok, request found
    pcr = it->second;

    TBFL_STDOUT("LvDevice::ack_client_request::handling request #" << pcr->id);
  }
  
  { //- CRITICAL SECTION
    yat::MutexLock guard(pcr->mtx);

    //- no waiter or tmo expired
    if ( pcr->state == CLIENT_REQ_STATE_PENDING_ASYNC )
    {
      //- waiter has leaved the place on timeout
      TBFL_STDOUT("LvDevice::ack_client_request::request #"
                  << pcr->id
                  << " is either async or timedout - removing it from repository");
      //- remove request from repository then simply (and silently) return
      _MOVE_PCR_TO_TRASH_;
      return;
    }
    else if ( pcr->state == CLIENT_REQ_STATE_EXPIRED )
    {
      //- waiter has leaved the place on timeout
      TBFL_STDOUT("LvDevice::ack_client_request::timeout expired for request #"
                  << pcr->id
                  << " - removing it from repository [that's weird cause we should never see any expired request here!]");
      //- remove request from repository then simply (and silently) return
      _MOVE_PCR_TO_TRASH_;
      return;
    }
    //-  request gave error?
    if ( ! _cl_rq_ack->error_code )
    {
      TBFL_STDOUT("LvDevice::ack_client_request::request #"
                  << pcr->id
                  << " successfully handled");
      pcr->state = CLIENT_REQ_STATE_HANDLED;
    }
    else
    {
      TBFL_STDOUT("LvDevice::ack_client_request::attaching error to request #"
                  << pcr->id);
      pcr->state = CLIENT_REQ_STATE_FAILED;
      pcr->error = ERROR_STACK->devfailed(_cl_rq_ack->error_stack);
    }

    TBFL_STDOUT("LvDevice::ack_client_request::signaling waiter for request #"
                << pcr->id);

    //- wake up waiter
    pcr->cdt.signal();
  }
}

//=============================================================================
// LvDevice::push_data_ready_event
//=============================================================================
void LvDevice::push_data_ready_event (const std::string& an, tbfl::int32 uc)
    throw (Tango::DevFailed)
{
  //------------------------------------------------------------------------
  //- this could generate a crash in case someone execute a "restart device"
  //- while trying to push a data ready event !!!!!
  //------------------------------------------------------------------------
  //- we consequently lock the device monitor in the hope that it will help
  //- to avoid the problem... (i.e. in the hope that the Tango kernel also
  //- acquires the device monitor before deleting/reinstantiating the device).
  //- I personally don't see how any implementation could guarantee the
  //- expected thread safety since the monitor is acquired using a pointer
  //- to the device which is deleted when "restart device" is executed.
  //------------------------------------------------------------------------
  AutoTangoMonitor guard(device_impl_);
 
  if ( device_impl_ )
  {
    device_impl_->push_data_ready_event(an, uc);
  }  
}


#endif //- _TBFL_HAS_DEVICE_SERVER_SUPPORT_


